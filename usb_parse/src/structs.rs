//! Data structures relevant to parsing sensor value data.
//! 
//! File: structs.rs
//! Author: Derek Guo
//! Version: 1
//! Date: 2022-11-13
//! 
//! Copyright (c) 2022

/* Namespaces */
use {
  serde::{
    Serialize,
    Deserialize,
  },
  serde_json::Value,
};

/* Immediate parsing format, derived from C */
#[derive(Debug, Copy, Clone, Deserialize)]
#[repr(C, packed(2))]
pub struct TeensyCanData {
  fl_wheel_speed: u16,
  fl_brake_temperature: u16,
  fr_wheel_speed: u16,
  fr_brake_temperature: u16,
  bl_wheel_speed: u16,
  bl_brake_temperature: u16,
  br_wheel_speed: u16,
  br_brake_temperature: u16,
  front_brake_pressure: u16,
  rear_brake_pressure: u16,
  garbage_fl_val: f32,
  packetnum: u16,
  signal_data: u8,
} // sizeof = 27

/* Higher level format, compatible with JSON */
// Includes reformatted versions of all floats
#[derive(Debug, Copy, Clone, Serialize)]
pub struct SensorVals {
  fl_wheel_speed: f32,
  fl_brake_temperature: f32,
  fr_wheel_speed: f32,
  fr_brake_temperature: f32,
  bl_wheel_speed: f32,
  bl_brake_temperature: f32,
  br_wheel_speed: f32,
  br_brake_temperature: f32,
  front_brake_pressure: i32,
  rear_brake_pressure: i32,
  garbage_fl_val: f32,
  packetnum: u16,
  signal_data: char,
}

impl SensorVals {
  /* Constructor */
  pub fn new(data: &TeensyCanData, sensor_list: &Value) -> SensorVals {
    /// Constructs a new SensorVals object, given deserialized but raw data from the Teensy
    /// and a reference to the information and formatting of each sensor.
    /// 
    /// # Contracts
    /// 
    /// The `sensor_list` object should be parsed from the `sensor_list.json` file. 
    /// The initial `data` is assumed to have been checked over by Serde and bincode's
    /// autogenerated deserializer, and all values are assumed to be valid. Should an
    /// erroneous value be output, e.g. a NaN, that may indicate a problem on the CAN
    /// and not the program itself.
    /// 
    /// Because of this, this function assumed no errors will need to be handled.
    #[allow(unused_doc_comments)]

    // Helper closure for Short (u16) TO Float (f32) conversion
    // This assumes that the JSON data given is formatted correctly,
    // and that the input data corresponds to the correct sensors.
    let stof = |sh: u16, name: &str| {
      (sh as f32) * (sensor_list[name]["scale"].as_f64().unwrap() as f32)
                  + (sensor_list[name]["bias"].as_f64().unwrap() as f32)
    };

    // Initialize and return
    SensorVals {
      fl_wheel_speed: stof(data.fl_wheel_speed, "fl_wheel_speed"),
      fl_brake_temperature: stof(data.fl_brake_temperature, "fl_brake_temperature"),
      fr_wheel_speed: stof(data.fr_wheel_speed, "fr_wheel_speed"),
      fr_brake_temperature: stof(data.fr_brake_temperature, "fr_brake_temperature"),
      bl_wheel_speed: stof(data.bl_wheel_speed, "bl_wheel_speed"),
      bl_brake_temperature: stof(data.bl_brake_temperature, "bl_brake_temperature"),
      br_wheel_speed: stof(data.br_wheel_speed, "br_wheel_speed"),
      br_brake_temperature: stof(data.br_brake_temperature, "br_brake_temperature"),
      front_brake_pressure: data.front_brake_pressure as i32,
      rear_brake_pressure: data.rear_brake_pressure as i32,
      garbage_fl_val: data.garbage_fl_val,
      packetnum: data.packetnum,
      signal_data: data.signal_data as char,
    }
  }
}